In Catspeak, Compiling and running programs are separate steps. You should aim
to perform any compilation of scripts during a loading screen so that running
your programs is much faster.

# Compiling Programs

The first step to running your Catspeak programs involves compiling the
source code from the human-readable form into an executable form. This can be
done in two ways: from a GML string, or from a character buffer.

## Compiling From a String

If your Catspeak program is stored within a GML string, you can use the
[catspeak_compile_string] function to compile it. For example, consider the
following program, stored in a multi-line GML string:
```
// counts to 10 and then returns a message
var src = @'
    let n = 0
    while (n <= 10) {
        print n
        n = it + 1
    }
    return "blast off!"
';
```
You can use the [catspeak_compile_string] function to spawn a
[CatspeakCompilerProcess]:
```
var process = catspeak_compile_string(src);
```
The `process` variable stores a reference to the compiler process
responsible for compiling the code you passed as a parameter.

As it stands, this example isn't very interesting because it ignores the
result produced by the compiler. In order to grab this result, the
[andThen] method on [CatspeakProcess] needs to be used:
```
process.andThen(function(code) {
    show_message(code.disassembly());
});
```
When the process completes, this callback function will be called with a
single parameter. This parameter will be the compiled program produced by
the compiler. In this example, the callback function uses the [disassembly]
method to display the debug representation of the program in a pop-up
window; it should look like this:
```
fun main() {
blk["init"]:
  r4 = LDC 3 ...
  JMP blk["entry"]
blk["entry"]:
  r0 = LDC 1 0
  JMP blk_3_5["while begin"]
blk_3_5["while begin"]:
  r1 = MOV 1 r0
  r2 = LDC 1 10
  r1 = CALL r4 r1 2
  JMPF blk_3_5["while end"] r1
  r1 = MOV 1 r0
  r1 = CALL r5 r1 1
  r2 = MOV 1 r0
  r3 = LDC 1 1
  r2 = CALL r6 r2 2
  r0 = MOV 1 r2
  JMP blk_3_5["while begin"]
  JMP blk_3_5["while end"]
blk_3_5["while end"]:
  r1 = LDC 2 undefined "blast off!"
  RET r2
  RET !
}
```
If you see an output similar to this, **congratulations!** You have
successfully compiled your first Catspeak program. For information on how to
run this program, see the [Executing Programs] section.

NOTE: The `LDC` instruction on line 3 has been shortened with `...`.

## Compiling From a Buffer

Compiling a buffer works similarly to [Compiling From a String], except you
use the [catspeak_compile_buffer] function:
```
catspeak_compile_buffer(buff).andThen(function(code) {
    show_message(code.disassembly());
});
```

Different from the [catspeak_compile_string] function, the buffer version
accepts an additional parameter, that if set to `true` will automatically
delete the buffer once the compiler process ends so you don't have to. By
default, this is set to `false`.

NOTE: The seek of this buffer will not be reset to the start, this is
      something you must maintain yourself.

# Executing Programs

The second step to running your Catspeak programs is to interpret the
compiled code. This can be done using the `catspeak_execute` function.
Following on from the example shown in [Compiling From a String], the
function contained in the `code` variable can be interpreted like so:
```
catspeak_execute(code).andThen(function(result) {
    show_message(result);
});
```
This will spawn a new [CatspeakVMProcess] which goes through the process of
interpreting the compiled code. Once the program has finished running, the
callback to the [andThen] method is called with the result of the program. In
this example, the result was the string `"blast off!"`, so a pop-up window
with the message "blast off!" will be shown.

If everything went to plan, you should have just compiled and executed your
first Catspeak program!

NOTE: If you do not care about the result of the call, you can just leave the
      [andThen] method blank.

## Global Variables

Before you use the [catspeak_execute] function to interpret your programs,
you can get and set global variables using the [getGlobal] and [setGlobal]
methods on [CatspeakFunction].

NOTE: If you want to call a script from Catspeak, you must use `method` to
      turn the script into a method struct beforehand, otherwise the
      interpreter will not see the script as a valid function reference:
      ```
      code.setGlobal("alert", method(, show_message));
      ```

# Configuring Programs

Both compiler and interpreter processes can be customised so that their time
limit or exception handler is different from the defaults defined using the
[catspeak_config] function. Use the [withTimeLimit] method to modify its time
limit, and the [catchError] method to modify the exception handler function:
```
catspeak_execute(code)
    .withTimeLimit(5) // 5 second time limit
    .catchError(function(e) {
        // handle the error by just outputting a debug message
        show_debug_message("an error occurred! " + string(e));
    })
    .andThen(function(result) {
        show_message(result);
    });
```